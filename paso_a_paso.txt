En este txt se encuentra paso a paso como fue desarrollando el proyecto de la tienda

Se crea la carpeta app que contedrá a su vez la carpeta static y templates.Se crea el entorno virtual, se activa, actualiza; se instala flask.

Se crea el archivo __init__.py dentro de app, para que la carpeta app, funcione como un paquete, lo que permite importar todo lo del paquete de forma directa.
Es en init donde se importa flask. Se crea una instancia de flask de nombre app y se crea una función (inicializar_app()) que retorne dicha app.

HINT: con ALt + Shift + F. VSC pregunta si se quiere instalar autopep8, si ya está instalado, le da el formato de la convención Pep8

En la ruta raíz, en este caso en Tienda, se crea el archivo manage.py. Aquí se puede desplegar de otra manera el servidor y poder
ver la aplicación en desarrollo. Es este archivo el que corremos en consola 

En init, se crea la primer ruta para que al correr el server,  nos da error 404, ya que no hemos creado nada todavía


    Creando los archivos de configuraciones:

Se crea el archivo config.py, en el cual se albergará la configuración para el proyecto. Se crean las clases Config (vacia),
DevelopmentConfig que hereda de config, un diccionario con llaves que son instancias de la clase. Para hacer esto funcionar, en el archivo init,
en el método que retorna la aplicación, se especifica el parámetro config. Se especifica que app tendrá una configuración que viene del objeto config
En manage se importa el módulo que acabamos de crear y el objeto config. Se crea una variable que su valor sea el valor de la llave development,
variable que será pasada como parámetro de la función inicializar_app.
Y todo esto para que dentro de las configuraciones de app.run, el depurador esté activo. Las clases creadas llevarán configuraciones más tarde

Para modificar el puerto o el host de nuestro server, se especifica cada uno de estos argumentos dentro del método app.run().
Por defecto los valores son: host = localhost , port = 5000. Ejemplo de otra config: app.run(host="10.100.100.10", port=9566)


    Manejo de error 404:

Ahora se manejará el error 404 al ingresar a una ruta que no exista en nuestra página.
En init se crea una funcion con el nombre del error, le pasamos un argumento que será tratado como el error y retorna un render_template
En la carpeta templates se crea otra carpeta de nombre errores, en la cual habrá plantillas para los errores.
Dentro se crea el archivo 404.html y se escribe una maqueta básica de un html. COn los mensajes del error
En init, en la return de la función pagina_no_encontrada, se especifica la ruta carpeta/archivo.html y como segundo parámetro del return, escribimos 404.

Se tiene que registrar un manejador de errores. dentro de inicializar_app se especifica el manejador de errores.
Como primer parámetro el error 404, y como segundo la función que creamos anteriormente.


    Creación de boques Jinja:

Dentro de templates se crea un archivo base.html, se le da la maqueta básica y se crea un bloque de titulo  jinja en la etiqueta del titulo y uno de body
Esta plantilla base, nos servirá para el formulario de inicio de sesión como para toda la intranet, es decir, todos los procedimientos internos de la app.
Se recomienda hacer bloques de importación de archivos css y js. Se  pueden crear bloques personalizados para poder importar estos archivos en las plantillas
que los usen. Entonces se importan en el template correspondiente. Solo se definen los bloques en base.html.

Se crea el archivo body.html dentro de templates, hereda de base y se crea un bloque body de jinja. Dentro se crea otro bloque containter

Creamos el archivo index.html. Esta plantilla renderizará la vista index desde init.py
Hereda de body, se crea un bloque de titulo y se le da el titulo index. También un bloque que contiene un mensaje provisional. Este mensaje se encuentra
en un bloque contenedor, el cual adaptará su contenido al bloque que corresponde a body, en body al bloque contenedor, lo contiene a su vez un bloque body
y como body.html hereda de base, el mensaje que viene desde index.html se adapta al bloque título de base.html


    Integrando Bootstrap con CDN para la barra de navegación:

Con todo esto configurado, en init.py la ruta raíz ya no retorna solo un string, sino un render_template.
Para estilizar los archivos CSS se usará el framework Bootstrap.
Se integra Bootstrap a través de CDN. Content Delivery Network (red de distribución de contenidos) o a través de la descarga e importación de los archivos
que se quieran utilizar, los cuales van dentro de /static. Con CDN: En un navegador web se busca Bootstrap y se busca la versión 4.6 (porqué esa?, no sé). 
Se copia el stylesheet que nos presenta la web y se pega en base.html después del título. Así se importa Bootstrap, pero se necesitan más importaciones ...
Se necesitan algunos archivos JS para poder crear efectos y funcionalidades. Se usa jquery, librería de js que permite interactuar con el DOM (Document Object Model)
de una forma más fácil. En la web, en el apartado de Separate vienen 3 etiqeutas scripts, los cuales se pegarán antes del bloque customJS de jinja
Con esto se cambia los estilos de Bootstrap, gracias a las importaciones que hicimos.

En body.html se crea una capa entre el bloque de body y el bloque container. Escribimos div.container y enter para que se cree la etiqueta automaticamente.
Movemos el bloque container adentro del div que creamos. Para mover el texto del mensaje Hola mundo, en los argumentos del div, se especifica py-5,
esto significa que se quiere un padding verticar de X unidades. El padding es un area de relleno en los lados que se le diga


    Creando la barra de navegación:

Se crea nav.html, en la web de Bootstrap sacamos una barra de navegación, dentro de su barra de navegación, en Components se busca Navbar y se selecciona una,
se copia se pega el contenido en nav. Se borran algunas etiquetas que no se usan, las <li> de nav-item, para no tener tantas opciones en la barra de navegación
En body.html se agrega una etiqueta de jinja que es {include 'archivo.html'}. Como su nombre lo dice, se incluye el contenido de ese archivo
Esta barra de navegación existirá en todo el sitio, excepto en el login.Cambiamos el nombre de la barra a "Tienda X", en la primer etiqueta li,
cambiamos el nombre a Index y en el argumento de la etiqueta li, le quitamos la propiedad de active, y la etiqueta span y comentamos las otras etiquetas.
En <item> Index, se tiene un atributo href, la cual hace referencia al mismo sitio mediante un numeral (#), en nuestra web, si se da click al boton index, no ocurre nada

En index.html creamos un div con el nombre de row, es decir fila, para poder contener más elementos. Dentro creamos otra etiqueta div con un texto que sirve
para que independientemente del tipo de pantalla, el contenido se muestre. Bootstrap usa un sistema de división de la pantalla en 12 espacios.
Dentro de los cuales se puede asignar bloques de diferente tamaño, mientras no rebasen los 12. Bootstrap redimensionará la página dependiendo
del dispositivo que la visite, esta característica se denomina RESPONSIVE y es una buena práctica. Colocamos el mensaje del h1 dentro del div que se acaba de crear.
Ahora, si hacemos pequeña la ventana del navegador, el contenido se moverá dependiendo del tamaño disponible!!!


    Bootstrap con la descarga e integración de la librería:

Durante todo este proceso se usaron los CDN de Bootstrap, pues la otra forma de usar Bootstrap es teniendo las librería dentro de static.
Creamos 4 carpetas img,css,js,lib de static. Importamos los archivos de Bootstrap y la imagen del curso.
Dentro de base.html. En <link>, en href se usa la funcion url_for y se especifica donde se encuentra el archivo a importar, se empieza con el css de Bootstrap
Posteriormente, donde se colocaban los script de popper, jquery y Bootstrap, se hace casi lo mismo, solo que en el href se especifica la ruta con una facilidad de jinja
Para hacer aparecer la pequeña imagen (svg) que se previamente colocamos en la carpeta img.
Importamos la imagen debajo de la etiqueta del titulo, colocamos una etiqueta link, pero en el atributo rel, no colocamos stylesheet, sino shortcut icon
y en href lo mismo, apuntamos a la posición de la imagen.


    Para el formulario o login:

En init creamos la ruta login, con su respectiva plantilla (login.html) en /templates/auth (de autenticacion).Para no tener que crear un formulario desde 0,
sacamos uno de la web de Bootstrap (https://getbootstrap.com/docs/5.3/examples/) En login.html, hereda de base, y contiene un bloque de título y uno de cuerpo
Con f12 checamos el código del login de ejemplo, copiamos todo el contenido de la etiqueta main y se coloca en el bloque body
Se agrega el atributo class a la <form> y se especifica que es un form-singin. En los input de los campos de texto agregamos (required autofocus),
Para que sean campos obligatorios y autofocus para que no sea necesario dar click en la casilla. 
Se debe agregar un archivo css para que el estilo sea identico al ejemplo. Archivo que se encuentra en el código de la web. 
El contenido lo meteremos a un archivo static/css/login.css. En una buena práctica el nombrar los archivos css de la misma manera
que la plantilla a la cual afectan. Para incluir el estilo que acabamos de obtener, se había creado anteriormente un bloque en base.html para los CSS
customizados. No se va a incluir el código en base, ya que afectaría a todas las rutas, entonces como login hereda de base, creamos el mismo bloque,
En una etiqueta link se especifica la ruta del archivo css. Jinja hará el resto

Nota: Si algo no está bien escrito, como puede ser el nombre de un atributo de una etiqueta, si corre, pero puede que la vista no funcione como debería

Para modificar el logo del formulario: en login.html, en la etiqueta img, modificamos el src (source).
Para centrar el logo, se hará con JS. Se crea un bloque jinja para JS en login y con una etiqueta script se señala el archivo.


    Usando JavaScript para centrar texto:

Se crea el archivo js. En login.js se usa la clase text-center para centrar todo el texto del cuerpo de la página
Se crea una constante que albergará el cuerpo del html, a través de la función querySelector, se para como parámetro el nombre de la etiqueta a seleccionar.
La constante body llama al método classList, el cual solo es de lectura, pero el método add, el cual estamos usando, agrega clases a las etiquetas html
y en este caso agregamos text-center. Con esta dos lineas de cogigo lo que se está haciendo es algo como: <body class='text-center'>
El documento JS necesita ser cargado ya cuando el resto de la página ya haya cargado, puesto que no tiene sentido centrar un texto que todavía no existe,
así pues, metemos las 2 lineas en una función. Esta función es equivalente al document.ready de jquery. Cuando el documento esté listo, se realizan una serie
de acciones


    Edición del login:

Cambiamos los textos que se presetan en el login. Para los carácteres especiales como los acentos, se recomienda usar (&oacute;) para la ó
otro ejemplo: &nacute; para la n. 
Cambiamos los campos de email por los de usuario, type, name, placeholder y el contenido de la etiqueta. Para password se deja casi todo igual, 
solo se agrega el campo name. Se eliminó un mensaje de bienvenida sin uso para nuestros intereses.


    Métodos HTTP:

Dentro del formulario (etiqueta form) se pueden aplicar dos atributos, aparte a las clases. Uno de ellos es action que indica a donde se manda el formulario
y method que indica la forma de envío, es aquí donde se especifica qué metodo HTTP se va a usar, get,post,put o delete, son algunos de  los verbos
GET es el método por defecto por los cuales se envían y procesan las peticiones a través de la web. Este método es el usado 
y en action se manda a la ruta /login
En el metodo login dentro de init, imprimimos request.method para ver el tipo de metodo, en la consola vemos: GET. 
En la ruta login se están enviando dos datos, name=usuario y name=password, pero no los estamos recibiendo. Para ver que es lo que manda el usuario se imprime
request.form['usuario'] y en otra password. Da un error, porque el método usado sigue siendo get y no post, 
ya que post puede recibir los datos  de un formulario y procesarlos. Por lo tanto, se condicionan las impresiones solo cuando el request.method sea igual a POST
Nos regresamos a login.html y cambiamos el método del form a POST. Si en el formulario mandamos datos nos dará error 405 method not allowed.
Esto ocurre ya que Flask nos permite configurar a cada ruta el tipo de método sobre el cual se realizará la petición. Para solucionarlo, en init, en el decorador
de login, se especifica como segundo parámetro, los métodos permitidos, por defecto solo es get. Si volvemos a mandar algo por usuario y password dará un TypeError
Esto ocurre porque falta el return del render_template. En consola podemos ver lo que mandó el usuario en los campos, algo importante a exponer, es que lo que mandó
el usuario por user y password se queda guardo en el server y no se filtra en la url, porque anteriormente, las respuestas dadas por el usuario se mostraban en la url
esto implica una falta de seguridad.
Como una prueba de un usuario con permisos de administrador, se crea la condicional donde el usuario debe ser admin y password es 123456, entonces redireccionamos
al usuario a la ruta index, con los metodos redirect y url_for. De esta manera se simula un inicio de sesión, ya recibiendo los datos que pasa el usuario


    CSRF:

Cross Site Request Forgery o Solicitud de Falsificación entre Sitios. Respecto a la seguridad de los formularios, el CSRF es un ataque, donde sitios ajenos al nuestro,
realizan peticiones a través de un formulario y no podemos controlar que esas peticiones sean de nuestro mismo sitio. Para controlar esa vulnerabilidad, Flask tiene
herramientas, para evitar que un sitio web ajeno realice peticiones en nuestro sitio web. Se necesita instalar Flask.WTF. Entonces, cada que te tengamos un formulario,
generamos un token o llave específica que puede identificarnos a la hora de realizar peticiones a través de formularios, con esto sabremos que somos nosotros quienes
hacen las solicitudes.

Nos vamos a config.py y en la clase Config (anteriormente vacia), creamos un atributo secret_key con valor de una cadena de texto, quedebería ser una contraseña
compleja. Con esta contraseña, la app podrá crear tokens para cada formulario y para cada petición que se esté realizando. En init tenemos que importar el modulo
instalado y creamos una instancia del módulo. Dentro de inicializar_app utilizamos la variable para instanciar la aplicación. Con esto ya se tiene la protección
de ataques CSRF. Por último, en login.html , al iniciar el formulario se crea un  <input> con el atributo hidden, de nombre csrf_token y el su valor será el que
nos arroje el método de {{csrf_token()}}, al ejecutarse el servidor, este valor, será sustituido con un código o token creado para ése formulario y peticiones.


    Validación con html:

Comprobaremos que los datos ingresados en los inputs sean los correctos. Dentro de login, en los inputs de usuario y password, podemos indicar atributos como minlengt o maxlength, para el tamaño de el string ingresado. Con esto validamos por medio de html la información a recibir, por medio de los atributos html 


    Introducción a Maria DB:

Para la persistencia de datos usamos una base de datos para albergarlos, porque actualmente son volátiles. MariaDB es una rama de MySQL. Se instala a través de XAMPP (Apache,MariaDB,PHP,Perl).
En la web se descarga e instala como un programa cualquiera. En la interfaz se pulsa start en las opciones de Apache y MySQL, posteriormente, en un navegador se ingresa a localhost y si todo está bien, se ingresa a una bienvenida de XAMPP, se ingresa a la pestaña phpMyAdmin, herramienta que nos permite trabajar con bases de datos MariaDB.

    
    Creación de una Base de Datos:

Dentro de phpMyAdmin se de click en nueva, se le da un nombre y en la codificación de caractes se selecciona utf8_unicode_ci y se pulsa en crear. Nuestra base de datos tendrá 5 tablas. 1. Tipos de usuario (admin o cliente) 2. Tabla para albergar a los usuarios, con sus claves y el tipo de usuario. 3. Libros que están a disposición 4. Autores de los libros 5. Tabla de compras, enlazamos un libro con un usuario.


    Creación de tablas:

Para la primer tabla de nombre tipousuario, solo lleva 2 columnas. Como siempre, la primer columna es el id que funciona como llave primaria. Entonces, se le da  el nombre de id, el tipo es tinyint y su longitud es de 1, como atributo es unsigned o sea, sin signo y se selecciona que es llave primaria.
Continuar. Se selecciona la casilla de A_I, de autoincrementar. La siguiente columna es el nombre, varchar de longitud 15. En la sección de comentarios se da una pequeña descripción de qué es lo que alberga la tabla, en cotejamiento se vuelve a seleccionar utf8_unicode_ci y listo, se da en guardar.
Y así con las siguientes tablas.

El password no se guarda como un texto plano, sino como un código encriptado.
La tabla de usuarios alberca una llave foranea, conectadose con la tabla tipo_usuario. El tipo de dato y el tamaño deben ser el mismo para que la llave primaria.
Para la tabla libro, la primer columna no es un id, sino un isbn, termino para referirse a libros, además, hace referencia a la tabla de autores con una llave foranea.
La tabla compra tiene un uuid, código único para identificar cada registro, como si fuese un código de barras, código aleatorio y único, permite identificar cada compra realizada.


    Relacionando las tablas:

Dentro de la base Tienda, en la opcion de Diseñador, podemos ver de manera más visual las tablas, ninguna de ellas se relaciona, para relacionarlas, en la opcion de SQL, podremos realizar consultas SQL. En la tabla de usuario, se tiene una referencia a la tabla de tipos de usuario, entonces, dentro del cuadro de texto de la opcion SQL (en la base) escribimos: \ALTER TABLE usuario\ Para señalar que la tabla se va a modificar, después: \ADD CONSTRAINT FK_usuario_tipousuario\ Para agregar una restricción entre la tabla donde ocurre la modificacion y la tabla que se referencia, y se inicia con FK por convencion de Foreign Key, después: \FOREIGN KEY (tipousuario_id) REFERENCES tipousuario (id);\ Se indica que es una restricción de una llave foranea (llave foranea de la tabla usuario) y que hace referencia a otra tabla (tipo de usuario) y dentro de esa tabla a una columna (su llave primaria). Con esto ya existe una relación entre las tablas de usuario y tipo de usuario. Pero para saber que todo está bien, dentro de las opciones de la tabla usuario, se visualiza una pequeña llave en la columna de la llave foranea, así como en la pestaña indices se observa la adición o de manera más visual en la opcion de Diseñador. Se hace lo mismo con la tabla libro y autor, y para la tabla compra, esta se relaciona con libro y usuario. El resultado final: (Tienda/imagenes/TiendaDB.png)


    Insertando datos con phpMyAdmin:

En la tabla de tipo_usuario, en la opcion de insertar, podemos insertar datos manualmente. Agregamos en la fila nombre y columna valor al Administrador  y en el siguiente registro al Cliente, quitando la casilla de Ignorar. Para visualizar que todo este vien, en la opcion de examinar se verán los registros. Para ingresar algunos autores, en los recursos del curso se encuentran algunas sentencias INSERT INTO, con información de autores, información que colocaremos en la ventana de SQL. Primero se ingresó algunos datos de autores, y no de libros o compras, porque las tablas de libro y compra dependen de autor. Para insertar datos para los libros igual están en los recursos del curso. Se puede visualizar el vínculo entre las tablas libro y autor por que existe un hipervinculo en cualquier numero que se pulse de la columna autor_id de la tabla libro, se redirecciona a una fila del autor seleccionado

    Configuración entre Flask y MariaDB:

Nota: para instalar ir a https://pypi.org/project/mysqlclient/ E instalar para la versión de Python corresponde, la mia es sudo apt-get install python3.12-dev default-libmysqlclient-dev build-essential pkg-config 
Instalamos mysqlclient, flask-mysql y flask-mysqldb. Ya instalado vamos a config.py para asignar a variables las configuraciones necesarias para poder conectarnos. Dentro de la clase DevelopmentConfig, agregamos el host de mysql el cual, en este momento es localhost, donde está corriendo la aplicación, también agregamos un usuario root, se llama así porque en el servidor de la base de datos, en la opcion Cuentas de usuarios, se llama de esa manera, y agregamos una contraseña tanto en phpMyAdmin como en la variable password.