En este txt se encuentra paso a paso como fue desarrollando el proyecto de la tienda

Se crea la carpeta app que contedrá a su vez la carpeta static y templates.Se crea el entorno virtual, se activa, actualiza; se instala flask.

Se crea el archivo __init__.py dentro de app, para que la carpeta app, funcione como un paquete, lo que permite importar todo lo del paquete de forma directa.
Es en init donde se importa flask. Se crea una instancia de flask de nombre app y se crea una función (inicializar_app()) que retorne dicha app.

HINT: con ALt + Shift + F. VSC pregunta si se quiere instalar autopep8, si ya está instalado, le da el formato de la convención Pep8

En la ruta raíz, en este caso en Tienda, se crea el archivo manage.py. Aquí se puede desplegar de otra manera el servidor y poder
ver la aplicación en desarrollo. Es este archivo el que corremos en consola 

En init, se crea la primer ruta para que al correr el server,  nos da error 404, ya que no hemos creado nada todavía


    Creando los archivos de configuraciones:

Se crea el archivo config.py, en el cual se albergará la configuración para el proyecto. Se crean las clases Config (vacia),
DevelopmentConfig que hereda de config, un diccionario con llaves que son instancias de la clase. Para hacer esto funcionar, en el archivo init,
en el método que retorna la aplicación, se especifica el parámetro config. Se especifica que app tendrá una configuración que viene del objeto config
En manage se importa el módulo que acabamos de crear y el objeto config. Se crea una variable que su valor sea el valor de la llave development,
variable que será pasada como parámetro de la función inicializar_app.
Y todo esto para que dentro de las configuraciones de app.run, el depurador esté activo. Las clases creadas llevarán configuraciones más tarde

Para modificar el puerto o el host de nuestro server, se especifica cada uno de estos argumentos dentro del método app.run().
Por defecto los valores son: host = localhost , port = 5000. Ejemplo de otra config: app.run(host="10.100.100.10", port=9566)


    Manejo de error 404:

Ahora se manejará el error 404 al ingresar a una ruta que no exista en nuestra página.
En init se crea una funcion con el nombre del error, le pasamos un argumento que será tratado como el error y retorna un render_template
En la carpeta templates se crea otra carpeta de nombre errores, en la cual habrá plantillas para los errores.
Dentro se crea el archivo 404.html y se escribe una maqueta básica de un html. COn los mensajes del error
En init, en la return de la función pagina_no_encontrada, se especifica la ruta carpeta/archivo.html y como segundo parámetro del return, escribimos 404.

Se tiene que registrar un manejador de errores. dentro de inicializar_app se especifica el manejador de errores.
Como primer parámetro el error 404, y como segundo la función que creamos anteriormente.


    Creación de boques Jinja:

Dentro de templates se crea un archivo base.html, se le da la maqueta básica y se crea un bloque de titulo  jinja en la etiqueta del titulo y uno de body
Esta plantilla base, nos servirá para el formulario de inicio de sesión como para toda la intranet, es decir, todos los procedimientos internos de la app.
Se recomienda hacer bloques de importación de archivos css y js. Se  pueden crear bloques personalizados para poder importar estos archivos en las plantillas
que los usen. Entonces se importan en el template correspondiente. Solo se definen los bloques en base.html.

Se crea el archivo body.html dentro de templates, hereda de base y se crea un bloque body de jinja. Dentro se crea otro bloque containter

Creamos el archivo index.html. Esta plantilla renderizará la vista index desde init.py
Hereda de body, se crea un bloque de titulo y se le da el titulo index. También un bloque que contiene un mensaje provisional. Este mensaje se encuentra
en un bloque contenedor, el cual adaptará su contenido al bloque que corresponde a body, en body al bloque contenedor, lo contiene a su vez un bloque body
y como body.html hereda de base, el mensaje que viene desde index.html se adapta al bloque título de base.html


    Integrando Bootstrap con CDN para la barra de navegación:

Con todo esto configurado, en init.py la ruta raíz ya no retorna solo un string, sino un render_template.
Para estilizar los archivos CSS se usará el framework Bootstrap.
Se integra Bootstrap a través de CDN. Content Delivery Network (red de distribución de contenidos) o a través de la descarga e importación de los archivos
que se quieran utilizar, los cuales van dentro de /static. Con CDN: En un navegador web se busca Bootstrap y se busca la versión 4.6 (porqué esa?, no sé). 
Se copia el stylesheet que nos presenta la web y se pega en base.html después del título. Así se importa Bootstrap, pero se necesitan más importaciones ...
Se necesitan algunos archivos JS para poder crear efectos y funcionalidades. Se usa jquery, librería de js que permite interactuar con el DOM (Document Object Model)
de una forma más fácil. En la web, en el apartado de Separate vienen 3 etiqeutas scripts, los cuales se pegarán antes del bloque customJS de jinja
Con esto se cambia los estilos de Bootstrap, gracias a las importaciones que hicimos.

En body.html se crea una capa entre el bloque de body y el bloque container. Escribimos div.container y enter para que se cree la etiqueta automaticamente.
Movemos el bloque container adentro del div que creamos. Para mover el texto del mensaje Hola mundo, en los argumentos del div, se especifica py-5,
esto significa que se quiere un padding verticar de X unidades. El padding es un area de relleno en los lados que se le diga


    Creando la barra de navegación:

Se crea nav.html, en la web de Bootstrap sacamos una barra de navegación, dentro de su barra de navegación, en Components se busca Navbar y se selecciona una,
se copia se pega el contenido en nav. Se borran algunas etiquetas que no se usan, las <li> de nav-item, para no tener tantas opciones en la barra de navegación
En body.html se agrega una etiqueta de jinja que es {include 'archivo.html'}. Como su nombre lo dice, se incluye el contenido de ese archivo
Esta barra de navegación existirá en todo el sitio, excepto en el login.Cambiamos el nombre de la barra a "Tienda X", en la primer etiqueta li,
cambiamos el nombre a Index y en el argumento de la etiqueta li, le quitamos la propiedad de active, y la etiqueta span y comentamos las otras etiquetas.
En <item> Index, se tiene un atributo href, la cual hace referencia al mismo sitio mediante un numeral (#), en nuestra web, si se da click al boton index, no ocurre nada

En index.html creamos un div con el nombre de row, es decir fila, para poder contener más elementos. Dentro creamos otra etiqueta div con un texto que sirve
para que independientemente del tipo de pantalla, el contenido se muestre. Bootstrap usa un sistema de división de la pantalla en 12 espacios.
Dentro de los cuales se puede asignar bloques de diferente tamaño, mientras no rebasen los 12. Bootstrap redimensionará la página dependiendo
del dispositivo que la visite, esta característica se denomina RESPONSIVE y es una buena práctica. Colocamos el mensaje del h1 dentro del div que se acaba de crear.
Ahora, si hacemos pequeña la ventana del navegador, el contenido se moverá dependiendo del tamaño disponible!!!


    Bootstrap con la descarga e integración de la librería:

Durante todo este proceso se usaron los CDN de Bootstrap, pues la otra forma de usar Bootstrap es teniendo las librería dentro de static.
Creamos 4 carpetas img,css,js,lib de static. Importamos los archivos de Bootstrap y la imagen del curso.
Dentro de base.html. En <link>, en href se usa la funcion url_for y se especifica donde se encuentra el archivo a importar, se empieza con el css de Bootstrap
Posteriormente, donde se colocaban los script de popper, jquery y Bootstrap, se hace casi lo mismo, solo que en el href se especifica la ruta con una facilidad de jinja
Para hacer aparecer la pequeña imagen (svg) que se previamente colocamos en la carpeta img.
Importamos la imagen debajo de la etiqueta del titulo, colocamos una etiqueta link, pero en el atributo rel, no colocamos stylesheet, sino shortcut icon
y en href lo mismo, apuntamos a la posición de la imagen.


    Para el formulario o login:

En init creamos la ruta login, con su respectiva plantilla (login.html) en /templates/auth (de autenticacion).Para no tener que crear un formulario desde 0,
sacamos uno de la web de Bootstrap (https://getbootstrap.com/docs/5.3/examples/) En login.html, hereda de base, y contiene un bloque de título y uno de cuerpo
Con f12 checamos el código del login de ejemplo, copiamos todo el contenido de la etiqueta main y se coloca en el bloque body
Se agrega el atributo class a la <form> y se especifica que es un form-singin. En los input de los campos de texto agregamos (required autofocus),
Para que sean campos obligatorios y autofocus para que no sea necesario dar click en la casilla. 
Se debe agregar un archivo css para que el estilo sea identico al ejemplo. Archivo que se encuentra en el código de la web. 
El contenido lo meteremos a un archivo static/css/login.css. En una buena práctica el nombrar los archivos css de la misma manera
que la plantilla a la cual afectan. Para incluir el estilo que acabamos de obtener, se había creado anteriormente un bloque en base.html para los CSS
customizados. No se va a incluir el código en base, ya que afectaría a todas las rutas, entonces como login hereda de base, creamos el mismo bloque,
En una etiqueta link se especifica la ruta del archivo css. Jinja hará el resto

Nota: Si algo no está bien escrito, como puede ser el nombre de un atributo de una etiqueta, si corre, pero puede que la vista no funcione como debería

Para modificar el logo del formulario: en login.html, en la etiqueta img, modificamos el src (source).
Para centrar el logo, se hará con JS. Se crea un bloque jinja para JS en login y con una etiqueta script se señala el archivo.


    Usando JavaScript para centrar texto:

Se crea el archivo js. En login.js se usa la clase text-center para centrar todo el texto del cuerpo de la página
Se crea una constante que albergará el cuerpo del html, a través de la función querySelector, se para como parámetro el nombre de la etiqueta a seleccionar.
La constante body llama al método classList, el cual solo es de lectura, pero el método add, el cual estamos usando, agrega clases a las etiquetas html
y en este caso agregamos text-center. Con esta dos lineas de cogigo lo que se está haciendo es algo como: <body class='text-center'>
El documento JS necesita ser cargado ya cuando el resto de la página ya haya cargado, puesto que no tiene sentido centrar un texto que todavía no existe,
así pues, metemos las 2 lineas en una función. Esta función es equivalente al document.ready de jquery. Cuando el documento esté listo, se realizan una serie
de acciones


    Edición del login:

Cambiamos los textos que se presetan en el login. Para los carácteres especiales como los acentos, se recomienda usar (&oacute;) para la ó
otro ejemplo: &nacute; para la n. 
Cambiamos los campos de email por los de usuario, type, name, placeholder y el contenido de la etiqueta. Para password se deja casi todo igual, 
solo se agrega el campo name. Se eliminó un mensaje de bienvenida sin uso para nuestros intereses.


    Métodos HTTP:

Dentro del formulario (etiqueta form) se pueden aplicar dos atributos, aparte a las clases. Uno de ellos es action que indica a donde se manda el formulario
y method que indica la forma de envío, es aquí donde se especifica qué metodo HTTP se va a usar, get,post,put o delete, son algunos de  los verbos
GET es el método por defecto por los cuales se envían y procesan las peticiones a través de la web. Este método es el usado 
y en action se manda a la ruta /login
En el metodo login dentro de init, imprimimos request.method para ver el tipo de metodo, en la consola vemos: GET. 
En la ruta login se están enviando dos datos, name=usuario y name=password, pero no los estamos recibiendo. Para ver que es lo que manda el usuario se imprime
request.form['usuario'] y en otra password. Da un error, porque el método usado sigue siendo get y no post, 
ya que post puede recibir los datos  de un formulario y procesarlos. Por lo tanto, se condicionan las impresiones solo cuando el request.method sea igual a POST
Nos regresamos a login.html y cambiamos el método del form a POST. Si en el formulario mandamos datos nos dará error 405 method not allowed.
Esto ocurre ya que Flask nos permite configurar a cada ruta el tipo de método sobre el cual se realizará la petición. Para solucionarlo, en init, en el decorador
de login, se especifica como segundo parámetro, los métodos permitidos, por defecto solo es get. Si volvemos a mandar algo por usuario y password dará un TypeError
Esto ocurre porque falta el return del render_template. En consola podemos ver lo que mandó el usuario en los campos, algo importante a exponer, es que lo que mandó
el usuario por user y password se queda guardo en el server y no se filtra en la url, porque anteriormente, las respuestas dadas por el usuario se mostraban en la url
esto implica una falta de seguridad.
Como una prueba de un usuario con permisos de administrador, se crea la condicional donde el usuario debe ser admin y password es 123456, entonces redireccionamos
al usuario a la ruta index, con los metodos redirect y url_for. De esta manera se simula un inicio de sesión, ya recibiendo los datos que pasa el usuario


    CSRF:

Cross Site Request Forgery o Solicitud de Falsificación entre Sitios. Respecto a la seguridad de los formularios, el CSRF es un ataque, donde sitios ajenos al nuestro,
realizan peticiones a través de un formulario y no podemos controlar que esas peticiones sean de nuestro mismo sitio. Para controlar esa vulnerabilidad, Flask tiene
herramientas, para evitar que un sitio web ajeno realice peticiones en nuestro sitio web. Se necesita instalar Flask.WTF. Entonces, cada que te tengamos un formulario,
generamos un token o llave específica que puede identificarnos a la hora de realizar peticiones a través de formularios, con esto sabremos que somos nosotros quienes
hacen las solicitudes.

Nos vamos a config.py y en la clase Config (anteriormente vacia), creamos un atributo secret_key con valor de una cadena de texto, quedebería ser una contraseña
compleja. Con esta contraseña, la app podrá crear tokens para cada formulario y para cada petición que se esté realizando. En init tenemos que importar el modulo
instalado y creamos una instancia del módulo. Dentro de inicializar_app utilizamos la variable para instanciar la aplicación. Con esto ya se tiene la protección
de ataques CSRF. Por último, en login.html , al iniciar el formulario se crea un  <input> con el atributo hidden, de nombre csrf_token y el su valor será el que
nos arroje el método de {{csrf_token()}}, al ejecutarse el servidor, este valor, será sustituido con un código o token creado para ése formulario y peticiones.


    Validación con html:

Comprobaremos que los datos ingresados en los inputs sean los correctos. Dentro de login, en los inputs de usuario y password, podemos indicar atributos como minlengt o maxlength, para el tamaño de el string ingresado. Con esto validamos por medio de html la información a recibir, por medio de los atributos html 


    Introducción a Maria DB:

Para la persistencia de datos usamos una base de datos para albergarlos, porque actualmente son volátiles. MariaDB es una rama de MySQL. Se instala a través de XAMPP (Apache,MariaDB,PHP,Perl).
En la web se descarga e instala como un programa cualquiera. En la interfaz se pulsa start en las opciones de Apache y MySQL, posteriormente, en un navegador se ingresa a localhost y si todo está bien, se ingresa a una bienvenida de XAMPP, se ingresa a la pestaña phpMyAdmin, herramienta que nos permite trabajar con bases de datos MariaDB. Para linux, se descarga e instala: https://phoenixnap.com/kb/how-to-install-xampp-on-ubuntu
Si da problemas al iniciar el servidor correctamente: https://stackoverflow.com/questions/16830891/mysql-is-not-starting-in-xampp-ubuntu Que se resume en estas líneas de código: 
>>cd /
>>sudo service mysql stop 
>>sudo /etc/init.d/apache2 stop         Si no jala, no hay pex
>>sudo /opt/lampp/lampp start
>>cd /opt/lampp
>>sudo ./manager-linux-x64.run
                                Se necesita crear un enlace entre las carpetas y hacer un vínculo, siempre que el server se reinicie
>>sudo mkdir /var/run/mysqld
>>sudo ln -s /opt/lampp/var/mysql/mysql.sock /var/run/mysqld/mysqld.sock


    Creación de una Base de Datos:

Dentro de phpMyAdmin se de click en nueva, se le da un nombre y en la codificación de caractes se selecciona utf8_unicode_ci y se pulsa en crear. Nuestra base de datos tendrá 5 tablas. 1. Tipos de usuario (admin o cliente) 2. Tabla para albergar a los usuarios, con sus claves y el tipo de usuario. 3. Libros que están a disposición 4. Autores de los libros 5. Tabla de compras, enlazamos un libro con un usuario.


    Creación de tablas:

Para la primer tabla de nombre tipousuario, solo lleva 2 columnas. Como siempre, la primer columna es el id que funciona como llave primaria. Entonces, se le da  el nombre de id, el tipo es tinyint y su longitud es de 1, como atributo es unsigned o sea, sin signo y se selecciona que es llave primaria.
Continuar. Se selecciona la casilla de A_I, de autoincrementar. La siguiente columna es el nombre, varchar de longitud 15. En la sección de comentarios se da una pequeña descripción de qué es lo que alberga la tabla, en cotejamiento se vuelve a seleccionar utf8_unicode_ci y listo, se da en guardar.
Y así con las siguientes tablas.

El password no se guarda como un texto plano, sino como un código encriptado.
La tabla de usuarios alberca una llave foranea, conectadose con la tabla tipo_usuario. El tipo de dato y el tamaño deben ser el mismo para que la llave primaria.
Para la tabla libro, la primer columna no es un id, sino un isbn, termino para referirse a libros, además, hace referencia a la tabla de autores con una llave foranea.
La tabla compra tiene un uuid, código único para identificar cada registro, como si fuese un código de barras, código aleatorio y único, permite identificar cada compra realizada.


    Relacionando las tablas:

Dentro de la base Tienda, en la opcion de Diseñador, podemos ver de manera más visual las tablas, ninguna de ellas se relaciona, para relacionarlas, en la opcion de SQL, podremos realizar consultas SQL. En la tabla de usuario, se tiene una referencia a la tabla de tipos de usuario, entonces, dentro del cuadro de texto de la opcion SQL (en la base) escribimos: \ALTER TABLE usuario\ Para señalar que la tabla se va a modificar, después: \ADD CONSTRAINT FK_usuario_tipousuario\ Para agregar una restricción entre la tabla donde ocurre la modificacion y la tabla que se referencia, y se inicia con FK por convencion de Foreign Key, después: \FOREIGN KEY (tipousuario_id) REFERENCES tipousuario (id);\ Se indica que es una restricción de una llave foranea (llave foranea de la tabla usuario) y que hace referencia a otra tabla (tipo de usuario) y dentro de esa tabla a una columna (su llave primaria). Con esto ya existe una relación entre las tablas de usuario y tipo de usuario. Pero para saber que todo está bien, dentro de las opciones de la tabla usuario, se visualiza una pequeña llave en la columna de la llave foranea, así como en la pestaña indices se observa la adición o de manera más visual en la opcion de Diseñador. Se hace lo mismo con la tabla libro y autor, y para la tabla compra, esta se relaciona con libro y usuario. El resultado final: (Tienda/imagenes/TiendaDB.png)


    Insertando datos con phpMyAdmin:

En la tabla de tipo_usuario, en la opcion de insertar, podemos insertar datos manualmente. Agregamos en la fila nombre y columna valor al Administrador  y en el siguiente registro al Cliente, quitando la casilla de Ignorar. Para visualizar que todo este vien, en la opcion de examinar se verán los registros. Para ingresar algunos autores, en los recursos del curso se encuentran algunas sentencias INSERT INTO, con información de autores, información que colocaremos en la ventana de SQL. Primero se ingresó algunos datos de autores, y no de libros o compras, porque las tablas de libro y compra dependen de autor. Para insertar datos para los libros igual están en los recursos del curso. Se puede visualizar el vínculo entre las tablas libro y autor por que existe un hipervinculo en cualquier numero que se pulse de la columna autor_id de la tabla libro, se redirecciona a una fila del autor seleccionado

    Configuración entre Flask y MariaDB:

Nota: para instalar ir a https://pypi.org/project/mysqlclient/ e instalar para la versión de Python corresponde, la mia es sudo apt-get install python3.12-dev default-libmysqlclient-dev build-essential pkg-config 
Instalamos mysqlclient, flask-mysql y flask-mysqldb. Ya instalado vamos a config.py para asignar a variables las configuraciones necesarias para poder conectarnos. Dentro de la clase DevelopmentConfig, agregamos el host de mysql el cual, en este momento es localhost, donde está corriendo la aplicación, también agregamos un usuario root, se llama así porque en el servidor de la base de datos, en la opcion Cuenta de usuarios, se llama de esa manera, y agregamos una contraseña (si se desea) tanto en phpMyAdmin como en la variable password. La 3er variable es  la Base de Datos, nombre que debe ser igual al puesto en phpMyAdmin.
Nos vamos a init e importamos mysql, instanciamos la clase y le pasamos la aplicación en la que queremos que tenga efecto y que permita conectarse a un sistema gestor MariaDB. COn esta instancia db se harán las conecciones a los modelos, los cuales son clases que albergarán todas las operaciones necesarias en la base de datos.


    Probando la conexión a la base:

Creamos una ruta de prueba, solo para ver que la conexión sea exitosa. Esta ruta debería conectarse a la tabla libros de la base, la cual ya tiene varias inserciones de datos. Se usan excepciones por cualquier problema que haya, levantamos una excepcion para que no se cuelgue el servidor. Creamos un cursor y una sentencia sql para seleccionar todas las columnas de la tabla libro y que los ordene por la columna titulo de manera ascendente. Creamos un objeto que alberge la data, se usa fetchall() para convertir lo obtenido a un objeto iterable, específicamente una tupla. Para ver los datos en la web, momentaneamente retornamos un template con una tabla de la información obtenida. La etiqueta tr define una fila de celdas en una tabla. Y con td se define la celda de una tabla que contiene datos. Para sacar información de una tabla ajena pero que esté haciendo referencia, hacemos la sentencia JOIN y señalamos que campos se unen con la sentencia ON. para una mejor lectura, se agrega un alias a las tablas y a sus columnas, para libros es LIB y para autores es AUT,

Nota: Por si cae una exepcion especifica: https://es.stackoverflow.com/questions/206679/error-2002-hy000-cant-connect-to-local-mysql-server-through-socket-var-run Que son:
>>sudo mkdir /var/run/mysqld
>>sudo ln -s /opt/lampp/var/mysql/mysql.sock /var/run/mysqld/mysqld.sock


    Modelos y entidades

Es una buena práctica crear modelos que se encargen de gestionar las entidades (tablas de la base) como lo pueden ser las conexiones a la base, operaciones CRUD, ... Creamos una subcarpeta de nombre models/entities. Dentro crearemos un archivo python para cada tabla/entidad de la base, creamos una clase del mismo nombre y sobreescribimos el constructor con atributos que son las columnas. Con esto reflejamos la lógica de cada entidad en la DB y controlamos los datos que cada una de ellas necesita para instanciarlas y presentar la data cuando se requiera. Creamos dentro de models un archivo __init__ para convertir esa carpeta en un paquete de python. Creamos los modelos de cada una des entidades, por ejemplo modelolibro tendrá una funcion para listar los elementos, dentro se crea la conección,se crea el cursor, la sentencia sql, ejecución del cursos y el procesamiento de los datos resultantes. método que transformamos en un método de clase para poder usarlo sin necesidad de instanciar la clase. Este método no debe retornar un render_template, eso es cosa de la vista y en este momento estamos en modelo, lo que vamos a hacer es importar los entidades creadas anteriormente y crear instnacias de la clase que alberguen los datos de la consulta, por medio de una iteración. Ya en la vista, dentro de la ruta /libros albergamos en una variable la lista que retornó el metodo de clase recien hecho, previamente importado el modulo. En el template modificamos lo que se muestra en las filas, accediendo a cada elemento de la lista dentro del diccionario.

    Gestión y encriptación de contraseñas

Para encriptar contraseñas usamos un módulo de Flask de nombre werkzeug y su submódulo security para generar contraseñas y compararlas con un input. Momentaneamente importamos (en init) y creamos la ruta password, las importaciones correspondientes van en usuario.py. Creamos una instancia de la clase y se pasamos un texto, en esta variable ya se encuentra la contraseña encriptada, creamos una instancia pero ahora de check y como primer parámetro es la contraseña encriptada y como segundo el string que queremos verificar si es la misma. La clave generada es la que guardamos en la base. Pasamos todo a usuario.py.
Nota: en el metodo de generate_password_hash se especifica como segundo parámetro el tipo de encriptación, para el curso usamos pbkdf2, pero existe una más segura, de nombre scrypt.


    Inicio de sesion

La comprobación de los usuarios y contraseñas deben ser comparados con la tabla de la base de datos. En ModeloUsuario.py se lleva a cabo la lógica de inicio de sesión. Se crea la conexión a la base y en la sentencia sql se selecciona de usuario los datos del usuario que mandó el cliente, si existe pasará información del usuario, sino la consulta dará error. De todos los campos seleccionados se selecciona un solo registro, esto con fetchone() porque solo debería haber 1 registro con el nombre del usuario. En init hacemos una instancia de la clase Usuario, con los atributos que obtenemos del cliente. Se crea otra instancia de ModeloUsuario donde le pasamos la base y el usuario creado en la linea anterior. En ModeloUsuario.py retornamos un booleano, si es verdadero, en init se accede a la pagina.
Dentro de la sentancia sql, como le estamos pasando un texto plano como usuario, este va dentro de comillas simples, valor que se sustituye por la propiedad de la variable usuario.usuario.
Se debe de condicionar a que la sentencia sql no sea None o al preguntar si la contraseña coincide se rompe el servidor, da None cuando el usuario que pasa el cliente no existe. 
PARA LA CONTRASEÑA. De mientras, se crea una variable que compare la contraseña pasada por el cliente y la contraseña guardada en la tabla, si es verdadero entonces se crea un usuario logeado con solo el id y el nombre del usuario y se retorna. En la vista se tiene un usuario que es una instancia de la clase Usuario donde pasamos la información que recibimos del cliente, después creamos otra instancia pero ahora de ModeloUsuario donde le pasamos la base y el usuario, la clase ModeloUsuario retorna 2 opciones,un objeto de tipo Usuario el cual ya contiene el usuario y el id de un usuario valido, o None, si se obtiene un usuario valido, se redirige a la web, si es None entonces se queda en login.


    Manejo de Sesiones

Cuando un usuario inicia sesión se espera que se mantenga iniciada y que pueda hacer ciertas acciones, una de ellas es cerrar la sesión. PAra poder manejar las sesiones: se instala, importa flask-login e instacia el submodulo LoginManager. En la ruta del inicio de sesión, usamos la funcion login_user() y como parámetro el usuario logeado anteriormente. Con estos do, con LoginManager creamos un administrador de sesiones para nuestro app y con login_user podemos logear el usuario que nosotros ya comprobamos que tiene un inicio de sesion exitoso, pero si ingresamos a login, nos hará falta una funcion para cargar el usuario y un método que intervenga con el administrador de login para traer los datos del usuario. Esto se hace para el control y gestión de sesiones funcione correctamente. Con el decorador de login creamos una funcion para cargar el usuario, por parámetro tendra el id del usuario a cargar y retorna una funcion con parámetros la base y el id a cargar. La funcion, se encuentra en ModeloUsuario la cual retorna los datos del usuario, leyendo por id. AL igual que con el método de clase login. obtener_por_id crea una conección a sql y ejecuta una sentencia, en la cual obtenemos los datos de usuario y tipousuario por medio del id que pasamos como parámetro en la funcion y retornamos un objeto Usuario con esos datos. Terminado esto de debe especificar que la clase Usuario hereda de UserMixin, modulo de flask-login.


    Cerrar sesión

Creamos una ruta logout, dentro llamamos al método logout, el cual viene con flask-login y redirigimos a login. Internamente se concluye la sesión, pero falta un botón dentro de la barra de navegación que diga cerrar sesión. Dentro de Templates/nav.html en el atributo href de <a> cambiamos el # por un url a index, tanto para el boton que presenta el titulo de la libreria como para el boton de index. Y agregamos una estructura similar pero ahora con la redireccion a la función logout y el texto de cerrar sesión.

    Mensajes flash

Si el usuario teclea mal su usuario o contraseña no hay un mensaje que se lo indique con el modulo flash de Flask podemos implementar esos mensajes entre distintas vistas para poder indicar datos que sean de utilidad para que el usuario pueda leer. Dentro de la ruta login, antes de redireccionar porque las credenciales no son validas, mandamos el mensaje flash, pero falta especificar donde mostrarlo, entonces vamos al template login, debajo del botón de iniciar sesión obtenemos los mensajes mandados por la función y los guardamos en una variable, realizamos una comprobación si hay mensajes y los iteramos para mostrarlos en pantalla. Para mejorar como se presenta el mensaje se usa un mensaje alerta de Bootstrap. Dentro de la etiqueta strong, modificamos el tamaño del texto a mostrar y entre las etiquetas mostramos el mensaje.
Cuando pulsamos para cerrar sesión, debería haber un mensaje que diga que cerramos sesión. Entonces hacemos lo mismo pero ahora en logout. Estos mensajes flash son constantes que van a ir en un archivo de variables constantes, lo importamos y sustituimos estas constantes dentro del mensaje flash.


    Categorías de mensajes flashed

Es posible hacer diferentes mensajes o diferentes propiedades a los mensajes, un mensaje de aviso es diferente a un mensaje de error. En los mensajes flash, le pasamos como segundo argumento la categoría del mensaje. Esto también debe ser cachado en el template, especificamente en la llamada de obtener lops mensajes, como parámetro le eindicamos que si vienen con categoria, también lo iteramos y lo seccionamos, dependiendo del tipo de categoria que tenga cada mensaje, para darle una vista diferente.Creamos un mensaje flash para la bienvenida de la página, todo lo anterior pero ahora en index, este mensaje aparece solo cuando se es redireccionado de login a index.


    Login requerido en URLs

Algunas de nuestras subrutas van a requerir obligatoriamente que el usuario se loge. Para hacer esto, en las rutas que se desee tener un usuario logeado se utiliza el decorador login_required debjo del decorar de la ruta. Si intentamos ingresar a una url y no estamos logeados, lanzará un mensaje de no autorización con el error 401. Pero este mensaje es muy feo para presentar al usuario, lo manejaremos redirigiendo a login. Dentro de init creamos la función para el error y la agregamos a inicializar_app. Con esto ya se redijie al usuario a login.


    Obtener sesión actual 

Mostraremos en la esquina superior los datos del usuario ya logeado. Cambiamos de lugar la tarea del check password de ModeloUsuario a un metodo de clase en Usuario.py.
Dentro del template de nav creamos un span al finalizar el ul. span aplica estilo al texto o agrupa elementos en linea. y le pasamos el usuario actual, elemento que nos presta flask-login para hacer referencia al usuario actual, el current_user se relaciona con la función de user_loder, la cual nos retorna los datos del usuario buscando por su id. agregamos el tipo de usuario y con la etiqueta strong se muestra en negritas. Para que el texto se vea en la esquina derecha. Dentro de lal atributo de ul agregamos mr-auto para que se acomode el texto.
Agregamos otro elemento a la barra de navegación que nos lleve al listado de libros y este listado solo se mostrara solo para los clientes. Los administradores no verán el elemento en la barra de navegación.


    Operaciones para control de sesiones

Dentro de la ruta raiz preguntamos si el usuario ya está autenticado, si es así, pasamos la platilla index, sino redireccionamos a login.
Los administrador podrán ver cuantos libros se han vendido, mientras que los clientes ven los libros que ya compraron. Esto se implementa en la ruta raiz. DEntro del template index creamos otra secci para mostar los libros o compras, en este momento solo mostramos el titulo de la lista. Los datos a mostrar vendrán de la lista del diccionario que a su vez sacan los datos de la base, esto es así para el dinamismo de la data. En el template de index tenemos la maqueta de las ventas o compras de los libros, vacia por el momento.


    Listado de libros disponibles 

Se va a mejorar la vista del listado de libros. Procedemos a borrar todo lo que haya en listado_libros, que solo era la iteración de un diccionario que contenia los datos de los libros. Reutilizamos bastante código de index.html. Para mostrar los datos y portadas de los libros usamos tarjetas de Bootstrap.
Para las imagenes, el curso nos regala las portadas en formato jpg, en el titulo de la imagen es su isbn para parearlas con la base de datos. Para hacer esto dentro del atributo src, en su segundo parámetro filename, donde se especifica la ruta de la imagen, incrustamos la variable que creamos con jinja2 con la palabra reservada set.


    Manejo de errores

Lo ideal es tener una página de errores que el usuario entienda que hubo un error, entonces, en vez de imprimir una excepcion retornamos un template con la excepcion como mensaje, todo esto en listado_libros. En error.html mandamos el error, este lo podemos poner en pantalla o no.


    Compra de libros, utilizando Fetch API

Complementaremos lo que existe en listado_libros.html creando un JS del mismo nombre. Al final del html creamos un bloque JS de jinja e importamos el archivo js. Dentro el botón de compra insertamos una clase botón para referenciarla desde el js y un id que es el isbn de los libros. Ya dentro del js, creamos una constante que es una referencia a todos los botones en html, después, al conjunto de botones seleccionados le agregamos a cada uno un evento de escucha o espera cada que se haga click se lanza una funcion anónima que a su vez lanza nuestra función confirmarCompra(). Para que todo el código JS funcione o sea leído debe ir dentro de la estructura de una función anónima entre paréntesis.
La función confirmarCompra que es una función lambda, usaremos FetchAPI, funcionalidad de JS para consumir APIs de manera remota, a través de JS puro, sin frameworks o librerias adicionales. esta función es asíncrona, es decir que va a esperar a otros procesos para ejecutar parte del código. Dentro, llamamos a fetch pasandole la ruta de libros/comprarlibro, ruta todavía no creada, como segundo parámetro de fetch le daremos una serie de opciones para indicar el método de envío, el modo, encabezados, el token y el cuerpo de la petición, y añadimos un await para esperar por la respuesta de la petición. en headers especificamos que el tipo de contenido que se espera es un json y un token. En el cuerpo de la petición le pasamos el isbn que es el mismo del libro seleccionado. la variable isbnLibro adquiere su valor cuando se pulsa en el boton comprar, es this.id por la referencia a cada elemento de los botones y id porque hacemos referencia al atributo del boton html.
Al finalizar el fetch mandamos una respuesta, si la respuesta no es valida entonces mandamos un error, si todo sale bien, retornamos al respuesta en formato json. Después teneos otro then con un mensaje al usuario cuando si verifique que el libro se compró. Para finalizar, creamos un catch para los errores, nota: se usan `templates strings` (``) identico a los f-strings de Python.
Nos vamos init a crear la ruta libros/comprarlibro. La data la enviamos desde el archivo correspondiente, en formato json, estamos enviando el libro seleccionado mediante la llave isbnLibro, asi pues, debemos recibir el cuerpo de la petición también como json, para poder obtener los datos que se están enviando, tambiénd ebemos indicar el token, que por el momento está vacío, par que esta petición sea válida. Entonces cachamos el json en una variable por medio de un método que no spermite obtener el json enviado como parte del cuerpo de la petición. este se puede imprimir un consola para verificar que todo a salido bien. En un diccionario almacenamos los mensajes de error o de exito de compra. Después, dentro de un bloque try, creamos un objeto instancia de la clase Libro y una llave-valor para los mensajes del diccionario, si falla, el valor del mensaje cambia a false y la excepcion como otro elemento del diccionario. Retornamos un tipo json, no un plantilla, flask tiene un método para jsonificar un diccionario. Esta respuesta es recibida por la petición en response del fetch.
Para el token, vamos a al html corresponde y creamos un input oculto, con su nombre y el valor. COn esto podemos obtener un token personalizado para cada formulario, en teste caso se usa o=para mandar correctamente la petición a través dela fetch API y que sea recibida por la vista correspondiente para realizar el proceso de compra. En el js creamos una constante para recibir el token, especficando el valor del atributo name del cual queremos el valor, dicha constante se pasa como el valor de la llave token. Ahora en el navegador, pulsamos el boton de comprar y en la consola del navegador debería de lanzarse el mensaje de exito al comprar y en consola  de VSC vemos el isbn.
En init, creamos una instancia de libro, pasandole el isbn obtenido del diccionario y otra instancia de compra, pasandole el objeto libro para el isbn y el usuario actual. Después le pasamos el objeto de tipo compra al metodo de clase para registar las compras. Este metodo retorna un valor booleano, el cual se lo pasamos a la llave exito del diccionario data.
En ModeloCompra creamos una clase del mismo nombre y el metodo de clase para registar las compras, se ahce la coneccion a la base y una sentencia insert de sql. Y para confirmar los cambios hechos, se usa el método commit, si todo va bien retornamos true.